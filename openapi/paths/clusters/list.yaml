get:
  operationId: listClusters
  tags: [clusters]
  summary: List all clusters
  description: |
    **List all clusters**
    
    Retrieve all clusters associated with your account. You can filter clusters by their status to find 
    clusters in specific states (PENDING, DEPLOYING, READY, or FAILED). This endpoint is useful for 
    monitoring cluster health and managing your infrastructure.

    **Examples**

    Here's an example of how to filter by status:
      ```
      /clusters?cluster_status=READY
      ```

  parameters: 
    - name: cluster_status
      in: query
      description: |
        Only return clusters of this status.
        Possible values:
        - `PENDING` - clusters that are pending (not yet deployed)
        - `DEPLOYING` - clusters that are being deployed
        - `READY` - clusters that are ready
        - `FAILED` - clusters that failed
      required: false
      schema:
        type: string
        enum: [PENDING, DEPLOYING, READY, FAILED]
        x-enum-varnames: [PENDING, DEPLOYING, READY, FAILED]
        description: >
          The status of the cluster.
          - `PENDING`: Cluster is pending (not yet deployed)
          - `DEPLOYING`: Cluster is being deployed
          - `READY`: Cluster is ready
          - `FAILED`: Cluster is failed

  responses:
    '200':
      $ref: '../../components/responses/clusters-list-response.yaml'
      useExample: success
    '404':
      $ref: '../../components/responses/error-response.yaml'
      useExample: cluster-not-found
    '500':
      $ref: '../../components/responses/error-response.yaml'
      useExample: server-error
  x-codeSamples:
    - lang: curl
      label: cURL
      source: |
        curl -X GET "https://api.exalsius.ai/clusters"
    - lang: python
      label: Python
      source: |
        import requests
        response = requests.get("https://api.exalsius.ai/clusters")
        print(response.json())

post:
  operationId: createCluster
  tags: [clusters]
  summary: Create a cluster
  description: |
    **Create a cluster**

    Create a new cluster.

    **Parameters**

    - `name`: The name of the cluster (required)
    - `cluster_type`: The type of cluster (required). Possible values: `CLOUD`, `REMOTE`, `ADOPTED`, `DOCKER`
    - `vpn_cluster`: Whether the cluster should be provisioned with VPN connectivity (optional, defaults to `false`)
    - `telemetry_enabled`: Enables observability/monitoring integrations for the cluster (optional, defaults to `false`)
    - `colony_id`: The ID of the colony to add the cluster to (optional)
    - `cluster_labels`: Arbitrary key/value labels applied to the cluster (optional)
    - `machine_pre_start_commands`: Commands to run on each machine before the cluster starts (optional)
    - `local_storage`: Local storage provisioner config. Supports `enabled` (bool, default `true`) and `basePath` (string) (optional)
    - `k8s_version`: The Kubernetes version of the cluster (optional, defaults based on cluster type)
    - `to_be_deleted_at`: The date and time the cluster will be deleted (optional)
    - `control_plane_node_ids`: The IDs of the control plane nodes (optional)
    - `worker_node_ids`: The IDs of the worker nodes (optional)
    - `service_deployments`: The services to deploy in the cluster (optional)

    If `to_be_deleted_at` is provided, the cluster will automatically be deleted at the specified date and time.
    If `control_plane_node_ids` or `worker_node_ids` are provided, the nodes will be added to the cluster.
    If `service_deployments` are provided, the services will be deployed in the cluster.
    If `local_storage` is configured, the storage provisioner will adopt the supplied settings when the cluster becomes ready.

    **Behavior:**
    - A new cluster resource will be created with the specified configuration
    - The cluster will be in the `PENDING` state until deployment is initiated
    - You must call `POST /cluster/{cluster_id}/deploy` to actually deploy the cluster
    - If nodes are specified, they will be associated with the cluster but not deployed until the deploy operation is called
    - If `service_deployments` are specified, services will be deployed after the cluster is ready

  requestBody: 
    required: true
    content: 
      application/json: 
        schema:
          $ref: '../../components/requests/cluster-create-request.yaml'
        examples:
          cloud-cluster:
            summary: Create a cloud cluster
            value:
              name: "my-cloud-cluster"
              cluster_type: "CLOUD"
              k8s_version: "1.30"
              control_plane_node_ids:
                - "123e4567-e89b-12d3-a456-426614174000"
              worker_node_ids:
                - "123e4567-e89b-12d3-a456-426614174001"
                - "123e4567-e89b-12d3-a456-426614174002"
          remote-cluster:
            summary: Create a remote cluster with self-managed nodes
            value:
              name: "my-remote-cluster"
              cluster_type: "REMOTE"
              k8s_version: "1.30"
              control_plane_node_ids:
                - "123e4567-e89b-12d3-a456-426614174003"
              worker_node_ids:
                - "123e4567-e89b-12d3-a456-426614174004"
  responses:
    '201':
      $ref: '../../components/responses/cluster-create-response.yaml'
      useExample: success
    '400':
      $ref: '../../components/responses/error-response.yaml'
      useExample: bad-request
    '409':
      $ref: '../../components/responses/error-response.yaml'
      useExample: cluster-already-exists
    '500':
      $ref: '../../components/responses/error-response.yaml'
      useExample: server-error
  
  x-codeSamples:
    - lang: curl
      label: cURL
      source: |
        curl -X POST "https://api.exalsius.ai/clusters" -H "Content-Type: application/json" -d '{"name": "my-cluster", "cluster_type": "CLOUD", "k8s_version": "1.30"}'
    - lang: python
      label: Python
      source: |
        import requests
        response = requests.post("https://api.exalsius.ai/clusters", json={"name": "my-cluster", "cluster_type": "CLOUD", "k8s_version": "1.30"})
        print(response.json())
