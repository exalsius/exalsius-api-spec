# coding: utf-8

"""
exalsius API

The exalsius REST API enables programmatic access to GPU infrastructure management and orchestration capabilities. Access the API through the `exls` command-line tool or integrate it directly into your applications using standard HTTP requests. The API covers several areas: * **GPU Market Offers** Browse and compare GPU instance pricing across public cloud providers and hyperscalers. * **Operator Integration** Coordinates with the [exalsius-operator](https://github.com/exalsius/exalsius-operator) running in a management Kubernetes cluster to handle infrastructure provisioning and node lifecycle management. * **Node Management** Import cloud-provider instances or self-managed nodes (via SSH) into your node pool. Hardware characteristics of self-managed nodes are discovered automatically. * **Cluster Provisioning** Create and manage Kubernetes clusters on supported cloud providers or self-managed bare-metal infrastructure. * **Service Deployment** Deploy infrastructure services such as the NVIDIA GPU Operator, KubeRay, Flyte, or Kubeflow onto your clusters. * **Workspace Deployment** Provision application workloads including Jupyter Notebook servers, LLM inference services, and other compute workloads on your clusters.

The version of the OpenAPI document: 1.38.0
Contact: support@exalsius.ai
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated

from exalsius_api_client.api_client import ApiClient, RequestSerialized
from exalsius_api_client.api_response import ApiResponse
from exalsius_api_client.models.node_delete_response import NodeDeleteResponse
from exalsius_api_client.models.node_import_response import NodeImportResponse
from exalsius_api_client.models.node_import_ssh_request import \
    NodeImportSshRequest
from exalsius_api_client.models.node_patch_request import NodePatchRequest
from exalsius_api_client.models.node_patch_response import NodePatchResponse
from exalsius_api_client.models.node_response import NodeResponse
from exalsius_api_client.models.nodes_list_response import NodesListResponse
from exalsius_api_client.rest import RESTResponseType


class NodesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def delete_node(
        self,
        node_id: Annotated[StrictStr, Field(description="ID of the node to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NodeDeleteResponse:
        """Delete a node from the pool

        **Delete a node from the pool**  Permanently delete a node from your node pool. This operation is only allowed when the node is in the  `AVAILABLE` state.  **Warning: This operation is irreversible.**  **Prerequisites:** - The node must be in the `AVAILABLE` state - If the node is currently in use (i.e., not available), you must first detach it from its cluster  **Behavior:** - The node will be permanently removed from your node pool - Once deleted, the node cannot be used in any cluster deployments - For cloud nodes, this does not terminate the instance; it only removes it from the pool - For self-managed nodes, the node is simply removed from management

        :param node_id: ID of the node to delete (required)
        :type node_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_node_serialize(
            node_id=node_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodeDeleteResponse",
            "404": "Error",
            "409": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_node_with_http_info(
        self,
        node_id: Annotated[StrictStr, Field(description="ID of the node to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NodeDeleteResponse]:
        """Delete a node from the pool

        **Delete a node from the pool**  Permanently delete a node from your node pool. This operation is only allowed when the node is in the  `AVAILABLE` state.  **Warning: This operation is irreversible.**  **Prerequisites:** - The node must be in the `AVAILABLE` state - If the node is currently in use (i.e., not available), you must first detach it from its cluster  **Behavior:** - The node will be permanently removed from your node pool - Once deleted, the node cannot be used in any cluster deployments - For cloud nodes, this does not terminate the instance; it only removes it from the pool - For self-managed nodes, the node is simply removed from management

        :param node_id: ID of the node to delete (required)
        :type node_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_node_serialize(
            node_id=node_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodeDeleteResponse",
            "404": "Error",
            "409": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_node_without_preload_content(
        self,
        node_id: Annotated[StrictStr, Field(description="ID of the node to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a node from the pool

        **Delete a node from the pool**  Permanently delete a node from your node pool. This operation is only allowed when the node is in the  `AVAILABLE` state.  **Warning: This operation is irreversible.**  **Prerequisites:** - The node must be in the `AVAILABLE` state - If the node is currently in use (i.e., not available), you must first detach it from its cluster  **Behavior:** - The node will be permanently removed from your node pool - Once deleted, the node cannot be used in any cluster deployments - For cloud nodes, this does not terminate the instance; it only removes it from the pool - For self-managed nodes, the node is simply removed from management

        :param node_id: ID of the node to delete (required)
        :type node_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_node_serialize(
            node_id=node_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodeDeleteResponse",
            "404": "Error",
            "409": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_node_serialize(
        self,
        node_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if node_id is not None:
            _path_params["node_id"] = node_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json", "application/problem+json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["OAuth2"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/node/{node_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def describe_node(
        self,
        node_id: Annotated[StrictStr, Field(description="ID of the node to describe")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NodeResponse:
        """Get details of a single node in the node pool (self-managed or cloud)

        **Retrieve the details of a single node in the node pool**  Fetch comprehensive metadata for a specific node in your pool. The response includes a `node_type`  property to distinguish between self-managed (SSH) nodes and cloud-imported instances. The response  structure varies based on the node type, with cloud nodes including pricing and instance information,  while self-managed nodes include SSH connection details and heartbeat information.

        :param node_id: ID of the node to describe (required)
        :type node_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._describe_node_serialize(
            node_id=node_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodeResponse",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def describe_node_with_http_info(
        self,
        node_id: Annotated[StrictStr, Field(description="ID of the node to describe")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NodeResponse]:
        """Get details of a single node in the node pool (self-managed or cloud)

        **Retrieve the details of a single node in the node pool**  Fetch comprehensive metadata for a specific node in your pool. The response includes a `node_type`  property to distinguish between self-managed (SSH) nodes and cloud-imported instances. The response  structure varies based on the node type, with cloud nodes including pricing and instance information,  while self-managed nodes include SSH connection details and heartbeat information.

        :param node_id: ID of the node to describe (required)
        :type node_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._describe_node_serialize(
            node_id=node_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodeResponse",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def describe_node_without_preload_content(
        self,
        node_id: Annotated[StrictStr, Field(description="ID of the node to describe")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get details of a single node in the node pool (self-managed or cloud)

        **Retrieve the details of a single node in the node pool**  Fetch comprehensive metadata for a specific node in your pool. The response includes a `node_type`  property to distinguish between self-managed (SSH) nodes and cloud-imported instances. The response  structure varies based on the node type, with cloud nodes including pricing and instance information,  while self-managed nodes include SSH connection details and heartbeat information.

        :param node_id: ID of the node to describe (required)
        :type node_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._describe_node_serialize(
            node_id=node_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodeResponse",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _describe_node_serialize(
        self,
        node_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if node_id is not None:
            _path_params["node_id"] = node_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json", "application/problem+json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["OAuth2"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/node/{node_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def import_node_from_offer(
        self,
        offer_id: StrictStr,
        hostname: Optional[StrictStr] = None,
        amount: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NodeImportResponse:
        """Import a node from an offer

        **Import cloud nodes into the pool**  Use this operation to import one or more nodes of a given cloud instance type into the node pool.  **Parameters**   - `offer_id`: The identifier of the cloud provider's offer you wish to import (see GET /offers).   - `amount`: The number of instances of the instance type to import.  **Behavior**  Importing a node from an offer to the node pool does not yet start a virtual machine and therefore does not yet involve any costs. A virtual machine of the given instance type will only be started when you deploy a cluster using the node. The `price_per_hour` of the node will be the price of the offer at the time of import. When deploying a cluster, the actual hourly rate will be the `price_per_hour` of the offer at that time.  **Result**  On success, you'll receive one or more node IDs. Use these IDs with the `/clusters` endpoint to add nodes to your clusters.

        :param offer_id: (required)
        :type offer_id: str
        :param hostname:
        :type hostname: str
        :param amount:
        :type amount: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._import_node_from_offer_serialize(
            offer_id=offer_id,
            hostname=hostname,
            amount=amount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "NodeImportResponse",
            "400": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def import_node_from_offer_with_http_info(
        self,
        offer_id: StrictStr,
        hostname: Optional[StrictStr] = None,
        amount: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NodeImportResponse]:
        """Import a node from an offer

        **Import cloud nodes into the pool**  Use this operation to import one or more nodes of a given cloud instance type into the node pool.  **Parameters**   - `offer_id`: The identifier of the cloud provider's offer you wish to import (see GET /offers).   - `amount`: The number of instances of the instance type to import.  **Behavior**  Importing a node from an offer to the node pool does not yet start a virtual machine and therefore does not yet involve any costs. A virtual machine of the given instance type will only be started when you deploy a cluster using the node. The `price_per_hour` of the node will be the price of the offer at the time of import. When deploying a cluster, the actual hourly rate will be the `price_per_hour` of the offer at that time.  **Result**  On success, you'll receive one or more node IDs. Use these IDs with the `/clusters` endpoint to add nodes to your clusters.

        :param offer_id: (required)
        :type offer_id: str
        :param hostname:
        :type hostname: str
        :param amount:
        :type amount: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._import_node_from_offer_serialize(
            offer_id=offer_id,
            hostname=hostname,
            amount=amount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "NodeImportResponse",
            "400": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def import_node_from_offer_without_preload_content(
        self,
        offer_id: StrictStr,
        hostname: Optional[StrictStr] = None,
        amount: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Import a node from an offer

        **Import cloud nodes into the pool**  Use this operation to import one or more nodes of a given cloud instance type into the node pool.  **Parameters**   - `offer_id`: The identifier of the cloud provider's offer you wish to import (see GET /offers).   - `amount`: The number of instances of the instance type to import.  **Behavior**  Importing a node from an offer to the node pool does not yet start a virtual machine and therefore does not yet involve any costs. A virtual machine of the given instance type will only be started when you deploy a cluster using the node. The `price_per_hour` of the node will be the price of the offer at the time of import. When deploying a cluster, the actual hourly rate will be the `price_per_hour` of the offer at that time.  **Result**  On success, you'll receive one or more node IDs. Use these IDs with the `/clusters` endpoint to add nodes to your clusters.

        :param offer_id: (required)
        :type offer_id: str
        :param hostname:
        :type hostname: str
        :param amount:
        :type amount: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._import_node_from_offer_serialize(
            offer_id=offer_id,
            hostname=hostname,
            amount=amount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "NodeImportResponse",
            "400": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _import_node_from_offer_serialize(
        self,
        offer_id,
        hostname,
        amount,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if offer_id is not None:
            _path_params["offer_id"] = offer_id
        # process the query parameters
        if hostname is not None:

            _query_params.append(("hostname", hostname))

        if amount is not None:

            _query_params.append(("amount", amount))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json", "application/problem+json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["OAuth2"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/node/import/offer/{offer_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def import_ssh(
        self,
        node_import_ssh_request: NodeImportSshRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NodeImportResponse:
        """Import a self-managed node via SSH

        **Import a self-managed node into the pool**  Use this operation to bring an existing server under SSH control into your node pool. The node will be added to the node pool and will be available to select for a cluster deployment.  **Parameters**  In order to import a self-managed node, you need to provide the following information: - The IP or hostname of the node with the SSH port (e.g. `192.168.1.1:22`) - The username to access the node - The ID of the SSH key to use for the node (see the SSH Keys endpoint)  **Behavior**  On success, the new node enters a `PENDING` state while we verify SSH connectivity and inspect its resources. This process may take up to 10 minutes; if it isn't ready by then, the import will fail. The node will transition to `AVAILABLE` once discovery is complete.  **Monitoring** You can poll its status at any time via GET /node/{node_id}.  **Result**  Returns the generated node ID. Use that ID with the `/clusters` endpoint to include this node in your cluster deployments.

        :param node_import_ssh_request: (required)
        :type node_import_ssh_request: NodeImportSshRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._import_ssh_serialize(
            node_import_ssh_request=node_import_ssh_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "NodeImportResponse",
            "400": "Error",
            "409": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def import_ssh_with_http_info(
        self,
        node_import_ssh_request: NodeImportSshRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NodeImportResponse]:
        """Import a self-managed node via SSH

        **Import a self-managed node into the pool**  Use this operation to bring an existing server under SSH control into your node pool. The node will be added to the node pool and will be available to select for a cluster deployment.  **Parameters**  In order to import a self-managed node, you need to provide the following information: - The IP or hostname of the node with the SSH port (e.g. `192.168.1.1:22`) - The username to access the node - The ID of the SSH key to use for the node (see the SSH Keys endpoint)  **Behavior**  On success, the new node enters a `PENDING` state while we verify SSH connectivity and inspect its resources. This process may take up to 10 minutes; if it isn't ready by then, the import will fail. The node will transition to `AVAILABLE` once discovery is complete.  **Monitoring** You can poll its status at any time via GET /node/{node_id}.  **Result**  Returns the generated node ID. Use that ID with the `/clusters` endpoint to include this node in your cluster deployments.

        :param node_import_ssh_request: (required)
        :type node_import_ssh_request: NodeImportSshRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._import_ssh_serialize(
            node_import_ssh_request=node_import_ssh_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "NodeImportResponse",
            "400": "Error",
            "409": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def import_ssh_without_preload_content(
        self,
        node_import_ssh_request: NodeImportSshRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Import a self-managed node via SSH

        **Import a self-managed node into the pool**  Use this operation to bring an existing server under SSH control into your node pool. The node will be added to the node pool and will be available to select for a cluster deployment.  **Parameters**  In order to import a self-managed node, you need to provide the following information: - The IP or hostname of the node with the SSH port (e.g. `192.168.1.1:22`) - The username to access the node - The ID of the SSH key to use for the node (see the SSH Keys endpoint)  **Behavior**  On success, the new node enters a `PENDING` state while we verify SSH connectivity and inspect its resources. This process may take up to 10 minutes; if it isn't ready by then, the import will fail. The node will transition to `AVAILABLE` once discovery is complete.  **Monitoring** You can poll its status at any time via GET /node/{node_id}.  **Result**  Returns the generated node ID. Use that ID with the `/clusters` endpoint to include this node in your cluster deployments.

        :param node_import_ssh_request: (required)
        :type node_import_ssh_request: NodeImportSshRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._import_ssh_serialize(
            node_import_ssh_request=node_import_ssh_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "NodeImportResponse",
            "400": "Error",
            "409": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _import_ssh_serialize(
        self,
        node_import_ssh_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if node_import_ssh_request is not None:
            _body_params = node_import_ssh_request

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json", "application/problem+json"]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["OAuth2"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/node/import/ssh",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def list_nodes(
        self,
        node_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Only return nodes of this type.   Possible values: - `SELF_MANAGED` - only self-managed (SSH) nodes   - `CLOUD` - only cloud-imported nodes "
            ),
        ] = None,
        provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Only return nodes of this provider. Example: - `aws` - only AWS node instances "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NodesListResponse:
        """List all imported nodes in the node pool

        **List nodes in the pool**  Retrieve all nodes in your node pool, including both self-managed (SSH) nodes and cloud-imported nodes. Nodes can be filtered by type and provider to help you find specific nodes.  **Filtering:** - `node_type`: Filter by node type - `CLOUD` for cloud-imported nodes or `SELF_MANAGED` for SSH-managed nodes - `provider`: Filter by cloud provider (e.g., \"aws\", \"azure\", \"gcp\") - only applies to cloud nodes  **Examples**  Here's an example of how to filter by node type:   ```   /nodes?node_type=SELF_MANAGED   ```      Here's an example of how to filter by provider:   ```   /nodes?provider=aws   ```

        :param node_type: Only return nodes of this type.   Possible values: - `SELF_MANAGED` - only self-managed (SSH) nodes   - `CLOUD` - only cloud-imported nodes
        :type node_type: str
        :param provider: Only return nodes of this provider. Example: - `aws` - only AWS node instances
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_nodes_serialize(
            node_type=node_type,
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodesListResponse",
            "422": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_nodes_with_http_info(
        self,
        node_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Only return nodes of this type.   Possible values: - `SELF_MANAGED` - only self-managed (SSH) nodes   - `CLOUD` - only cloud-imported nodes "
            ),
        ] = None,
        provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Only return nodes of this provider. Example: - `aws` - only AWS node instances "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NodesListResponse]:
        """List all imported nodes in the node pool

        **List nodes in the pool**  Retrieve all nodes in your node pool, including both self-managed (SSH) nodes and cloud-imported nodes. Nodes can be filtered by type and provider to help you find specific nodes.  **Filtering:** - `node_type`: Filter by node type - `CLOUD` for cloud-imported nodes or `SELF_MANAGED` for SSH-managed nodes - `provider`: Filter by cloud provider (e.g., \"aws\", \"azure\", \"gcp\") - only applies to cloud nodes  **Examples**  Here's an example of how to filter by node type:   ```   /nodes?node_type=SELF_MANAGED   ```      Here's an example of how to filter by provider:   ```   /nodes?provider=aws   ```

        :param node_type: Only return nodes of this type.   Possible values: - `SELF_MANAGED` - only self-managed (SSH) nodes   - `CLOUD` - only cloud-imported nodes
        :type node_type: str
        :param provider: Only return nodes of this provider. Example: - `aws` - only AWS node instances
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_nodes_serialize(
            node_type=node_type,
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodesListResponse",
            "422": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_nodes_without_preload_content(
        self,
        node_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Only return nodes of this type.   Possible values: - `SELF_MANAGED` - only self-managed (SSH) nodes   - `CLOUD` - only cloud-imported nodes "
            ),
        ] = None,
        provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Only return nodes of this provider. Example: - `aws` - only AWS node instances "
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all imported nodes in the node pool

        **List nodes in the pool**  Retrieve all nodes in your node pool, including both self-managed (SSH) nodes and cloud-imported nodes. Nodes can be filtered by type and provider to help you find specific nodes.  **Filtering:** - `node_type`: Filter by node type - `CLOUD` for cloud-imported nodes or `SELF_MANAGED` for SSH-managed nodes - `provider`: Filter by cloud provider (e.g., \"aws\", \"azure\", \"gcp\") - only applies to cloud nodes  **Examples**  Here's an example of how to filter by node type:   ```   /nodes?node_type=SELF_MANAGED   ```      Here's an example of how to filter by provider:   ```   /nodes?provider=aws   ```

        :param node_type: Only return nodes of this type.   Possible values: - `SELF_MANAGED` - only self-managed (SSH) nodes   - `CLOUD` - only cloud-imported nodes
        :type node_type: str
        :param provider: Only return nodes of this provider. Example: - `aws` - only AWS node instances
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_nodes_serialize(
            node_type=node_type,
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodesListResponse",
            "422": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_nodes_serialize(
        self,
        node_type,
        provider,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if node_type is not None:

            _query_params.append(("node_type", node_type))

        if provider is not None:

            _query_params.append(("provider", provider))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json", "application/problem+json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["OAuth2"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/nodes",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def patch_node(
        self,
        node_id: StrictStr,
        node_patch_request: Optional[NodePatchRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NodePatchResponse:
        """Patch a node

        **Patch a node**  Update a node's properties or send a heartbeat signal. This endpoint is typically used by node agents  to report status updates and maintain connectivity.  **Behavior:** - If request body is provided, the node's properties (description, hardware specs) will be updated - If no request body is provided, this acts as a heartbeat to indicate the node is still active - For self-managed nodes, this updates the `last_heartbeat_date` - Returns an access token that can be used for subsequent operations

        :param node_id: (required)
        :type node_id: str
        :param node_patch_request:
        :type node_patch_request: NodePatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._patch_node_serialize(
            node_id=node_id,
            node_patch_request=node_patch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodePatchResponse",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def patch_node_with_http_info(
        self,
        node_id: StrictStr,
        node_patch_request: Optional[NodePatchRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NodePatchResponse]:
        """Patch a node

        **Patch a node**  Update a node's properties or send a heartbeat signal. This endpoint is typically used by node agents  to report status updates and maintain connectivity.  **Behavior:** - If request body is provided, the node's properties (description, hardware specs) will be updated - If no request body is provided, this acts as a heartbeat to indicate the node is still active - For self-managed nodes, this updates the `last_heartbeat_date` - Returns an access token that can be used for subsequent operations

        :param node_id: (required)
        :type node_id: str
        :param node_patch_request:
        :type node_patch_request: NodePatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._patch_node_serialize(
            node_id=node_id,
            node_patch_request=node_patch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodePatchResponse",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def patch_node_without_preload_content(
        self,
        node_id: StrictStr,
        node_patch_request: Optional[NodePatchRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Patch a node

        **Patch a node**  Update a node's properties or send a heartbeat signal. This endpoint is typically used by node agents  to report status updates and maintain connectivity.  **Behavior:** - If request body is provided, the node's properties (description, hardware specs) will be updated - If no request body is provided, this acts as a heartbeat to indicate the node is still active - For self-managed nodes, this updates the `last_heartbeat_date` - Returns an access token that can be used for subsequent operations

        :param node_id: (required)
        :type node_id: str
        :param node_patch_request:
        :type node_patch_request: NodePatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._patch_node_serialize(
            node_id=node_id,
            node_patch_request=node_patch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "NodePatchResponse",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _patch_node_serialize(
        self,
        node_id,
        node_patch_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if node_id is not None:
            _path_params["node_id"] = node_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if node_patch_request is not None:
            _body_params = node_patch_request

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json", "application/problem+json"]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["OAuth2"]

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/node/{node_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
