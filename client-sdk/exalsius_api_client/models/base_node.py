# coding: utf-8

"""
exalsius API

The exalsius REST API provides programmatic access to the core functionality of the exalsius ecosystem It is consumed directly by the exls CLI tool and can also be integrated into custom applications or scripts. Key points: * **CLI & Programmatic Access**   All operations are available via the `exls` command-line application or through standard HTTP requests.  * **GPU Market Offers** Retrieve and compare GPU instance pricing across public cloud providers and hyperscalers to identify the most cost-effective options. * **Operator Integration**   Works in conjunction with the [exalsius-operator](https://github.com/exalsius/exalsius-operator) deployed in a management Kubernetes cluster, to manage infrastructure and node lifecycles.  * **Node Management**   Import self-managed (SSH) and cloud-provider instances into your node pool with dedicated endpoints.  * **Cluster Provisioning**   Create and manage Kubernetes clusters across supported cloud providers and self-managed (bare-metal) nodes.  * **Service Deployment**   Deploy additional services—such as the NVIDIA GPU Operator, KubeRay, Flyte, or Kubeflow—using the API’s service-deployment endpoints.

The version of the OpenAPI document: 1.13.1
Contact: support@exalsius.ai
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from datetime import datetime
from importlib import import_module
from typing import (TYPE_CHECKING, Any, ClassVar, Dict, List, Optional, Set,
                    Union)

from pydantic import (BaseModel, ConfigDict, Field, StrictInt, StrictStr,
                      field_validator)

if TYPE_CHECKING:
    from exalsius_api_client.models.cloud_node import CloudNode
    from exalsius_api_client.models.self_managed_node import SelfManagedNode


class BaseNode(BaseModel):
    """
    BaseNode
    """  # noqa: E501

    id: StrictStr = Field(description="The unique identifier for the node")
    node_type: StrictStr = Field(
        description="The type of the node. - `CLOUD`: Cloud node - `SELF_MANAGED`: Self-managed node "
    )
    hostname: Optional[StrictStr] = Field(
        default=None, description="The hostname of the node"
    )
    description: Optional[StrictStr] = Field(
        default=None, description="Description of the node"
    )
    location: Optional[StrictStr] = Field(
        default=None,
        description="The location of the node (e.g. city, data center, server rack, etc.)",
    )
    gpu_count: Optional[StrictInt] = Field(
        default=None, description="The number of GPUs"
    )
    gpu_vendor: Optional[StrictStr] = Field(
        default=None, description="The vendor of the GPU"
    )
    gpu_type: Optional[StrictStr] = Field(
        default=None, description="The type of the GPU"
    )
    gpu_memory: Optional[StrictInt] = Field(
        default=None, description="The memory of the GPU in GB"
    )
    cpu_cores: Optional[StrictInt] = Field(
        default=None, description="The number of CPU cores"
    )
    memory_gb: Optional[StrictInt] = Field(
        default=None, description="The memory of the node in GB"
    )
    storage_gb: Optional[StrictInt] = Field(
        default=None, description="The storage of the node in GB"
    )
    import_time: Optional[datetime] = Field(
        default=None, description="The time the node was imported"
    )
    node_status: StrictStr = Field(
        description="The status of the node. - `PENDING`: Node is pending, e.g. because it wasn't launched yet (CloudNode) or because it wasn't discovered yet (SelfManagedNode) - `AVAILABLE`: Node is available to be added to a cluster - `STAGED`: Node is staged in a cluster - `OCCUPIED`: Node is occupied in a cluster "
    )
    __properties: ClassVar[List[str]] = [
        "id",
        "node_type",
        "hostname",
        "description",
        "location",
        "gpu_count",
        "gpu_vendor",
        "gpu_type",
        "gpu_memory",
        "cpu_cores",
        "memory_gb",
        "storage_gb",
        "import_time",
        "node_status",
    ]

    @field_validator("node_type")
    def node_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(["CLOUD", "SELF_MANAGED"]):
            raise ValueError("must be one of enum values ('CLOUD', 'SELF_MANAGED')")
        return value

    @field_validator("node_status")
    def node_status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(["PENDING", "AVAILABLE", "STAGED", "OCCUPIED"]):
            raise ValueError(
                "must be one of enum values ('PENDING', 'AVAILABLE', 'STAGED', 'OCCUPIED')"
            )
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    # JSON field name that stores the object type
    __discriminator_property_name: ClassVar[str] = "node_type"

    # discriminator mappings
    __discriminator_value_class_map: ClassVar[Dict[str, str]] = {
        "CLOUD": "CloudNode",
        "SELF_MANAGED": "SelfManagedNode",
    }

    @classmethod
    def get_discriminator_value(cls, obj: Dict[str, Any]) -> Optional[str]:
        """Returns the discriminator value (object type) of the data"""
        discriminator_value = obj[cls.__discriminator_property_name]
        if discriminator_value:
            return cls.__discriminator_value_class_map.get(discriminator_value)
        else:
            return None

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Union[CloudNode, SelfManagedNode]]:
        """Create an instance of BaseNode from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(
        cls, obj: Dict[str, Any]
    ) -> Optional[Union[CloudNode, SelfManagedNode]]:
        """Create an instance of BaseNode from a dict"""
        # look up the object type based on discriminator mapping
        object_type = cls.get_discriminator_value(obj)
        if object_type == "CloudNode":
            return import_module(
                "exalsius_api_client.models.cloud_node"
            ).CloudNode.from_dict(obj)
        if object_type == "SelfManagedNode":
            return import_module(
                "exalsius_api_client.models.self_managed_node"
            ).SelfManagedNode.from_dict(obj)

        raise ValueError(
            "BaseNode failed to lookup discriminator value from "
            + json.dumps(obj)
            + ". Discriminator property name: "
            + cls.__discriminator_property_name
            + ", mapping: "
            + json.dumps(cls.__discriminator_value_class_map)
        )
